#include <iostream>
#include <queue>

using namespace std;

/*
19.07.19.금.
파이프 제거. flood fill 문제라고 하셨다.
bfs로 풀었는데.. 허허. 아무튼 간에.
파이프가 서로 연결이 되어있는 것을 어떻게 표현해야 되는지 모르겠어서
다른 사람이 푼 방법을 참고했다. 그림을 0과 1로 나타내서 저장을 했더라. 그래서 그 아이디어를 사용해 봄.
bit 연산은 못하겠어서 그냥 안했고 경우에 따라 idx를 이용해 연결상태를 확인했다.
모든 파이프의 모양을 나타내는 데 시간도 걸리고.. 생각하는 데도 헷갈려가지고 난리를 부림.. ㅎㅎ;

그리고 사실 A B를 입력받는 데서 어떻게 해야되나 했는데,
숫자를 문자로 받았으면 '0'을 빼면 숫자가 되고
문자를 받았으면 'A'를 받고 10을 더해주면 된다는 것을 알게됐다. 신기하네.
다음에도 필요한 일 있으면 써먹어야겠음.

아무튼.. 신기한(?) 문제였다.
*/

int n;
int arr[10][10];
int check[10][10];
int dir[4][2]={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};//상 하 좌 우 

int pipe[12][4]={{0, 0, 0, 0}, {0, 0, 1, 1}, {1, 1, 0, 0}, {0, 1, 0, 1}, 
				{0, 1, 1, 0}, {1, 0, 1, 0}, {1, 0, 0, 1}, {1, 1, 0, 1}, 
				{0, 1, 1, 1}, {1, 1, 1, 0}, {1, 0, 1, 1}, {1, 1, 1, 1}};

//범위 맞는지 체크.
bool isinside(int y, int x)
{
	if(y>=0&&y<n&&x>=0&&x<n)
		return true;
	else
		return false;
}

int bfs(int y, int x)
{
	//사용한 파이프의 수를 센다.
	int usedpipe=0;

	//시작 지점부터 bfs를 시작한다.
	queue<pair<int,int>> q;
	q.push(make_pair(y, x));
	check[y][x]=1;
	usedpipe++;//시작 지점의 파이프는 사용.

	//큐가 비지 않을 때까지 돈다.
	while(!q.empty())
	{
		int cy=q.front().first;
		int cx=q.front().second;
		q.pop();

		for(int i=0;i<4;i++)
		{
			int ny=cy+dir[i][0];
			int nx=cx+dir[i][1];

			//범위에 맞으며 아직 사용되지 않은 파이프인 경우 확인해본다.
			if(isinside(ny, nx)&&check[ny][nx]==0)
			{
				//확인을 하는 곳이 상, 하, 좌, 우에 따라 다르므로 그에 맞는
				//위치를 따로 구해서(다른 방법이 생각나지 않음) 확인한다.
				int idx1, idx2;
				if(i==0) //현재 파이프의 위에 있는 새로운 파이프를 확인하고 싶으면, 나의 상과 위의 하가 연결이 되는지 확인해야 된다.
				{
					idx1=0;
					idx2=1;
				}
				else if(i==1) //아래 있는 것과 확인하고 싶으면 나의 하와 아래의 상이 연결 되는지 확인!
				{
					idx1=1;
					idx2=0;
				}
				else if(i==2) //마찬가지로 좌.
				{
					idx1=2;
					idx2=3;
				}
				else //마찬가지로 우.
				{
					idx1=3;
					idx2=2;
				}

				//그 위치에 있는 파이프가 어떤 형태인지를 받는다.
				int a=arr[cy][cx];
				int b=arr[ny][nx];
				
				//형태와 idx 값으로 서로 비교해 서로 연결이 되어 있다면 큐에 넣어준다.
				if(pipe[a][idx1]&&pipe[b][idx2])//둘 다 1이라면
				{
					//큐에 넣어준다.
					q.push(make_pair(ny, nx));
					check[ny][nx]=1; //연결이 되어있음을 알린다. 
					//안돼있다면, 다른 파이프를 통해 연결이 될 수도 있으므로 넘어가자.
					usedpipe++;//사용한 파이프 값을 증가시킨다.
				}
			}

		}
	}

	//사용한 파이프의 수를 return한다.
	return usedpipe;
}


int main()
{
	cin>>n;
	int x, y;
	cin>>x>>y;

	char ch;
	
	//모든 파이프의 수를 세어서 마지막에 사용한 파이프의 수를 빼면 사용하지 않은 파이프의 수.
	int allpipe=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			//캐릭터 형태로 받아서 숫자로 변환해 넣어주자. 다른 방법이 생각나지 않습니다.. 뭔가 16진수 써도 될 것 같기도 한데.
			cin>>ch;
			if(ch<='9') //9 이하의 수라면 그냥 바로 변경.
				arr[i][j]=ch-'0';
			else //9이상의 수라서 A B로 받았다면 A를 뺀 후 10을 더해주면 된다.
				arr[i][j]=ch-'A'+10;

			//0이 아니라면, 파이프가 있는 것이므로 센다.
			if(arr[i][j]!=0)
				allpipe++;
		}

	int p = bfs(y, x);//수도 공급원에서 시작해 사용한 파이프의 수를 리턴받는다.
	cout<< allpipe-p <<endl;//정답은 모든 파이프에서 사용한 파이프를 뺀 것이다.

	return 0;
}
