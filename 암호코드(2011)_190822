#include<iostream>
#include<string>
using namespace std;

int num[5001];
int d[5001];
int mod = 1000000;

/*
19.08.22.목.
2011 암호코드 문제인데.
d[i]가 i번째 수로 만들 수 있는 해석의 가짓수라고 하는데요.
0번째 수로 만들 수 있는 암호 해석 가짓수는 없는 거 하나라는 말인가.. ??
(이런 거 정말 싫다...)

숫자를 저런식으로 받기 때문에 스트링으로 받아서 처리해주고

이게 일의 자리만 되는건지 2의 자리까지 되는건지를 확인해야되는데.
i번째 자리의 num값이 0이상 9이하라면 한자리는 만들 수 있는 거니까
지금의 i번째 자리로 만들 수 있는 한자리 수는 이전 자리의 값인 d[i-1]에다가 더해주면 된다..?

1의 자리로 가능한지를 볼 때는 당연히...
이미 설정이 안 되어있는 상태이기 때문에 d[i]를 구할 때 그냥 d[i-1]값만 더하면 되는데
근데 왜 이전 거를 더함..?? ^.^아.. 왜..??

와 진짜 이해 개 안된다. ㅎ.ㅎ.ㅎ.

이전까지 한 거를 더해준다는 의미지..거기다가 추가한다고. 내 결과를..?

더해주는 게 아니라 나를 1의 자리로 인식을 하면
당연히 앞에것들을 그렇게 인식을 한 다음에 나를 인식을 하는거니까
더하는 개념이 아니라 저장을 해주는 개념인 것 같은데.

*/

int main()
{
	string s;
	cin >> s;

	for (int i = 1; i <= s.size(); i++)
		num[i] = s[i - 1]-'0';

	d[0] = 1;
	for (int i = 1; i <= s.size(); i++)
	{
		if (1 <= num[i] && num[i] <= 9)
		{
			//cout << d[i] << endl;
			d[i] = d[i - 1] % mod;
			//d[i] = (d[i] + d[i - 1]) % mod;
		}
		if (i == 1) continue; // 두 자리 수가 당연히 안되기 때문이다.
		if (num[i - 1] == 0) continue; // 두 자리 수가 안되기 때문이다.
		if (10 <= num[i - 1] * 10 + num[i] && num[i - 1] * 10 + num[i] <= 26) //알파벳 범위에 맞아야 
			d[i] = (d[i] + d[i - 2]) % mod;
	}

	if (s.size() == 1 && num[1] == 0)
		cout << 0 << endl;
	else 
		cout << d[s.size()] << endl;

	return 0;
}
